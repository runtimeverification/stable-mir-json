# Stable MIR JSON Schema Documentation

This document describes the JSON schema for Rust Stable MIR (Mid-level Intermediate Representation) output generated by the `stable-mir-json` tool.

## Overview

The Stable MIR JSON format provides a complete serialization of Rust's MIR after monomorphization, containing all information needed for code generation, optimization, and analysis. The JSON schema ensures consistent structure and enables validation of generated files.

## Schema Location

The JSON schema is located at: `schema/stable-mir.schema.json`

## Usage

### Validating JSON Files

Use the provided validation script to check JSON files against the schema:

```bash
# Validate all test files
./scripts/validate-schema.sh

# Validate specific files
./scripts/validate-schema.sh path/to/file.smir.json

# Verbose validation
./scripts/validate-schema.sh --verbose
```

### Integration with Tools

The schema can be used with various JSON validation tools:

```bash
# Using ajv-cli (install with: npm install -g ajv-cli)
ajv validate -s schema/stable-mir.schema.json -d "path/to/file.smir.json"

# Using jsonschema (Python - install with: pip install jsonschema)
python -c "
import json, jsonschema
schema = json.load(open('schema/stable-mir.schema.json'))
data = json.load(open('path/to/file.smir.json'))
jsonschema.validate(data, schema)
print('âœ“ Valid')
"
```

## Root Structure

Every Stable MIR JSON file has the following top-level structure:

```json
{
  "name": "crate_name",
  "crate_id": 12345,
  "allocs": [...],
  "functions": [...],
  "uneval_consts": [...],
  "items": [...],
  "types": [...],
  "spans": [...],
  "debug": {...},
  "machine": {...}
}
```

### Root Fields

| Field | Type | Description |
|-------|------|-------------|
| `name` | `string` | Name of the crate |
| `crate_id` | `integer` | Unique identifier for the crate |
| `allocs` | `array` | Memory allocations indexed by AllocId |
| `functions` | `array` | Function symbols referenced in the program |
| `uneval_consts` | `array` | Unevaluated constants |
| `items` | `array` | Monomorphized items (functions, statics, etc.) |
| `types` | `array` | Type information with metadata |
| `spans` | `array` | Source location spans |
| `debug` | `object/null` | Optional debug information |
| `machine` | `object` | Target machine information |

## Key Data Structures

### Allocations (`allocs`)

Array of `[AllocId, AllocInfo]` tuples representing memory allocations:

```json
[
  [0, {"Memory": {"align": 1, "bytes": [72, 101, 108, 108, 111], "mutability": "Not", "provenance": {"ptrs": []}}}],
  [1, {"Static": 42}]
]
```

**AllocInfo variants:**
- `Memory`: Raw memory with alignment, bytes, mutability, and pointer provenance
- `Static`: Reference to a static item by DefId
- `Function`: Function allocation
- `VTable`: Virtual table allocation

### Functions (`functions`)

Array of `[LinkMapKey, FnSymType]` tuples representing function symbols:

```json
[
  ["main", {"NormalSym": "_ZN4main4main17h..."}],
  [{"Some": "complex_key"}, {"IntrinsicSym": "black_box"}]
]
```

**FnSymType variants:**
- `NormalSym`: Regular function with mangled symbol name
- `IntrinsicSym`: Compiler intrinsic function
- `NoOpSym`: No-operation placeholder

### Items (`items`)

Array of monomorphized items representing the actual code and data:

```json
{
  "symbol_name": "_ZN4main4main17h...",
  "mono_item_kind": {
    "MonoItemFn": {
      "name": "main::main",
      "id": 42,
      "body": {
        "arg_count": 0,
        "blocks": [...],
        "locals": [...],
        "span": 123,
        "spread_arg": null,
        "var_debug_info": []
      }
    }
  },
  "details": null
}
```

**MonoItemKind variants:**
- `MonoItemFn`: Function with optional MIR body
- `MonoItemStatic`: Static item with optional allocation
- `MonoItemGlobalAsm`: Global assembly code

### Types (`types`)

Array of `[Ty, TypeMetadata]` tuples providing type information with layout:

```json
[
  [{...}, {"PrimitiveType": {"layout": {...}, "prim_type": "Bool"}}],
  [{...}, {"StructType": {"layout": {...}, "name": "MyStruct", "field_types": [0, 1, 2]}}]
]
```

**TypeMetadata variants:**
- `PrimitiveType`: Basic types (bool, integers, floats)
- `StructType`: Structure types with field information
- `EnumType`: Enumeration types with discriminants
- `UnionType`: Union types
- `TupleType`: Tuple types
- `ArrayType`: Fixed-size arrays
- `SliceType`: Dynamic slices

### MIR Body Structure

Function bodies contain detailed MIR information:

```json
{
  "arg_count": 2,
  "blocks": [
    {
      "statements": [
        {
          "kind": {"Assign": [{"local": 0, "projection": []}, {"Use": {"Copy": {"local": 1, "projection": []}}}]},
          "span": 45
        }
      ],
      "terminator": {
        "kind": "Return",
        "span": 46
      }
    }
  ],
  "locals": [
    {"mutability": "Mut", "span": 44, "ty": 0},
    {"mutability": "Not", "span": 44, "ty": 1}
  ],
  "span": 44,
  "spread_arg": null,
  "var_debug_info": []
}
```

## Layout Information

Every type includes complete layout information for target-specific code generation:

```json
{
  "abi": {"Scalar": {...}},
  "abi_align": 4,
  "fields": {"Primitive"},
  "size": 4,
  "variants": {"Single": {"index": 0}}
}
```

**ABI variants:**
- `Uninhabited`: No valid values exist
- `Scalar`: Single scalar value
- `ScalarPair`: Pair of scalar values
- `Vector`: SIMD vector type
- `Aggregate`: Complex aggregate type

**Field shapes:**
- `Primitive`: Single primitive field
- `Union`: Union with multiple overlapping fields
- `Array`: Array with count and stride
- `Arbitrary`: Arbitrary field layout with explicit offsets

## Advanced Features

### Memory Provenance

Memory allocations include provenance tracking for pointer safety:

```json
{
  "provenance": {
    "ptrs": [[0, 7], [8, 15]]  // [offset, allocation_id] pairs
  }
}
```

### Debug Information

Optional debug information provides additional metadata:

```json
{
  "debug": {
    "fn_sources": [...],
    "types": {...},
    "foreign_modules": [...]
  }
}
```

### Source Spans

All MIR elements reference source locations through span indices:

```json
{
  "spans": [
    [0, {"file": "src/main.rs", "line": 1, "column": 5}],
    [1, {"file": "src/main.rs", "line": 2, "column": 10}]
  ]
}
```

## Validation

The schema provides comprehensive validation including:

- **Structure validation**: Ensures correct nesting and required fields
- **Type validation**: Validates data types and value ranges
- **Enum validation**: Ensures only valid enum variants are used
- **Reference validation**: Checks that indices reference valid entries
- **Layout consistency**: Validates layout information consistency

## Best Practices

### Working with the Schema

1. **Always validate**: Use the validation script before processing files
2. **Handle optionals**: Many fields are optional (`null` values)
3. **Follow indices**: Use indices to look up referenced data
4. **Respect layout**: Use layout information for target-specific operations
5. **Check variants**: Always handle all possible enum variants

### Performance Considerations

1. **Lazy loading**: Parse only needed sections for large files
2. **Index caching**: Cache frequently accessed indices
3. **Stream processing**: Use streaming parsers for very large files
4. **Schema validation**: Validate once, then trust the structure

## Schema Evolution

The schema follows semantic versioning:

- **Major version**: Breaking changes to structure or semantics
- **Minor version**: Backwards-compatible additions
- **Patch version**: Bug fixes and clarifications

Current version: **1.0.0**

## Examples

### Minimal Valid File

```json
{
  "name": "hello_world",
  "crate_id": 1,
  "allocs": [],
  "functions": [],
  "uneval_consts": [],
  "items": [],
  "types": [],
  "spans": [],
  "debug": null,
  "machine": {}
}
```

### Simple Function

```json
{
  "name": "example",
  "crate_id": 1,
  "allocs": [],
  "functions": [
    [{"fn_def": 0}, {"NormalSym": "_ZN7example4main17h..."}]
  ],
  "uneval_consts": [],
  "items": [{
    "symbol_name": "_ZN7example4main17h...",
    "mono_item_kind": {
      "MonoItemFn": {
        "name": "example::main",
        "id": 0,
        "body": {
          "arg_count": 0,
          "blocks": [{
            "statements": [],
            "terminator": {"kind": "Return", "span": 0}
          }],
          "locals": [{"mutability": "Mut", "span": 0, "ty": 0}],
          "span": 0,
          "spread_arg": null,
          "var_debug_info": []
        }
      }
    },
    "details": null
  }],
  "types": [
    [{}, {"PrimitiveType": {"layout": {"abi": "Uninhabited", "abi_align": 1, "fields": "Primitive", "size": 0, "variants": {"Single": {"index": 0}}}, "prim_type": {"Tuple": 0}}}]
  ],
  "spans": [
    [0, {"file": "src/main.rs", "line": 1, "column": 0}]
  ],
  "debug": null,
  "machine": {}
}
```

## Troubleshooting

### Common Validation Errors

1. **Missing required fields**: Ensure all root fields are present
2. **Invalid types**: Check that numbers are numbers, strings are strings
3. **Invalid array structures**: Arrays should contain proper tuple structures
4. **Invalid enum variants**: Ensure enum variants match schema exactly
5. **Index out of bounds**: Verify that all indices reference existing elements

### Getting Help

- Check the validation script output for specific error messages
- Examine the schema file for detailed type definitions
- Compare against working examples in the test directory
- Review the Rust source code for serialization logic

## Contributing

To improve the schema:

1. Update `schema/stable-mir.schema.json`
2. Run `./scripts/validate-schema.sh` to test changes
3. Update this documentation
4. Add test cases if needed
5. Submit a pull request

The schema should remain synchronized with the Rust serialization code in `src/printer.rs`.